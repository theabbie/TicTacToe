<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      @font-face {
        font-family: Gilroy;
        src: url("Gilroy.otf") format("opentype");
      }
      body {
        margin: 0;
        overflow-y: hidden;
      }
      * {
        box-sizing: border-box;
        font-family: Gilroy;
      }
      #board {
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
      }
      line,
      path,
      circle {
        stroke-linecap: round;
        stroke-dasharray: 850;
        stroke-dashoffset: 850;
        animation: draw 0.6s linear forwards;
      }
      line {
        animation-duration: 1s;
      }
      text tspan {
        font-size: 5.5em;
        fill: #fff;
        text-anchor: middle;
        fill: #121212;
        stroke: white;
        stroke-width: 2px;
      }
      @keyframes draw {
        to {
          stroke-dashoffset: 0;
        }
      }
    </style>
    <title>Tic Tac Toe</title>
  </head>
  <body>
    <svg id="board"></svg>
  </body>
  <script>
    let game = {};
    let state = {};
    let throttle;
    const wait = (fn, delay) =>
      new Promise((resolve) =>
        setTimeout(() => {
          if (fn) fn();
          resolve();
        }, delay)
      );
    const board = document.querySelector("#board");
    const windowWidth = "100%";
    const windowHeight = "100vh";
    board.setAttribute("width", windowWidth);
    board.setAttribute("height", windowHeight);
    board.style.backgroundColor = "#121212";

    const CROSS = "X";
    const CIRCLE = "O";

    function drawLine(x1, y1, x2, y2, color) {
      const line = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "line"
      );
      line.setAttribute("x1", x1);
      line.setAttribute("y1", y1);
      line.setAttribute("x2", x2);
      line.setAttribute("y2", y2);
      line.setAttribute("stroke", color || "white");
      line.setAttribute("stroke-width", game.strokeWidth);
      board.appendChild(line);
    }

    async function drawMoves() {
      let moves = state.moves.slice();
      state.moves = [];
      for (let move of moves) {
        await wait(() => markCell(move.x, move.y), 100);
      }
    }

    function drawScore(player) {
      let scoreBoard = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "text"
      );
      let xpos, ypos;
      if (game.w > game.h) {
        xpos = player == CROSS ? game.w / 10 : (game.w * 9) / 10;
        ypos = game.h / 2;
      } else {
        xpos = game.w / 2;
        ypos = player == CROSS ? game.h / 9 : (game.h * 5) / 6;
      }
      score = state.winners.filter((winner) => winner === player).length;
      scoreBoard.setAttribute("y", ypos);
      scoreBoard.innerHTML = `<tspan class="score" x=${xpos} dy="0">${score}</tspan><tspan class="score" x=${xpos} dy="0.6em">â€”</tspan><tspan x=${xpos} dy="0.7em">${player}</tspan>`;
      board.appendChild(scoreBoard);
    }

    async function drawBoard() {
      board.querySelectorAll("*").forEach((el) => el.remove());
      game.w = board.clientWidth;
      game.h = board.clientHeight;
      game.side = Math.min(game.w, game.h) / 1.2;
      game.boxSide = game.side / 3;
      game.cellPadding = game.boxSide / 6;
      game.strokeWidth = game.boxSide / 19;
      game.wBegin = (game.w - game.side) / 2;
      game.hBegin = (game.h - game.side) / 2;
      drawScore(CROSS);
      drawScore(CIRCLE);
      for (let i = 1; i <= 2; i++) {
        await wait(
          () =>
            drawLine(
              game.wBegin,
              game.hBegin + i * game.boxSide,
              game.wBegin + game.side,
              game.hBegin + i * game.boxSide
            ),
          250
        );
        await wait(
          () =>
            drawLine(
              game.wBegin + i * game.boxSide,
              game.hBegin,
              game.wBegin + i * game.boxSide,
              game.hBegin + game.side
            ),
          250
        );
      }
      await wait(null, 1000);
      await drawMoves();
    }

    function drawCross(x, y) {
      const cross = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      cross.setAttribute(
        "d",
        `M${game.wBegin + game.cellPadding + x * game.boxSide},${
          game.hBegin + game.cellPadding + y * game.boxSide
        } L${game.wBegin - game.cellPadding + (x + 1) * game.boxSide},${
          game.hBegin - game.cellPadding + (y + 1) * game.boxSide
        } M${game.wBegin + game.cellPadding + x * game.boxSide},${
          game.hBegin - game.cellPadding + (y + 1) * game.boxSide
        } L${game.wBegin - game.cellPadding + (x + 1) * game.boxSide},${
          game.hBegin + game.cellPadding + y * game.boxSide
        }`
      );
      cross.setAttribute("stroke", "white");
      cross.setAttribute("stroke-width", game.strokeWidth);
      board.appendChild(cross);
    }

    function drawCircle(x, y) {
      const circle = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      circle.setAttribute("cx", game.wBegin + (x + 0.5) * game.boxSide);
      circle.setAttribute("cy", game.hBegin + (y + 0.5) * game.boxSide);
      circle.setAttribute("r", game.boxSide / 2 - game.cellPadding);
      circle.setAttribute("stroke", "white");
      circle.setAttribute("stroke-width", game.strokeWidth);
      circle.setAttribute("fill", "none");
      board.appendChild(circle);
    }

    function switchPlayer(player) {
      if (player == CROSS) {
        return CIRCLE;
      } else {
        return CROSS;
      }
    }

    function isMoveValid(player, x, y) {
      for (let move of state.moves) {
        if (move.x == x && move.y == y) {
          return false;
        }
      }
      return true;
    }

    function drawWinnerLine(winner) {
      switch (winner.type) {
        case "row":
          drawLine(
            game.wBegin + game.boxSide / 2,
            game.hBegin + (winner.y + 0.5) * game.boxSide,
            game.wBegin + game.side - game.boxSide / 2,
            game.hBegin + (winner.y + 0.5) * game.boxSide,
            "red"
          );
          break;
        case "col":
          drawLine(
            game.wBegin + (winner.x + 0.5) * game.boxSide,
            game.hBegin + game.boxSide / 2,
            game.wBegin + (winner.x + 0.5) * game.boxSide,
            game.hBegin + game.side - game.boxSide / 2,
            "red"
          );
          break;
        case "diag":
          switch (winner.slope) {
            case -1:
              drawLine(
                game.wBegin + game.boxSide / 2,
                game.hBegin + game.boxSide / 2,
                game.wBegin + game.side - game.boxSide / 2,
                game.hBegin + game.side - game.boxSide / 2,
                "red"
              );
              break;
            case 1:
              drawLine(
                game.wBegin + game.boxSide / 2,
                game.hBegin + game.side - game.boxSide / 2,
                game.wBegin + game.side - game.boxSide / 2,
                game.hBegin + game.boxSide / 2,
                "red"
              );
              break;
          }
          break;
      }
    }

    function markCell(x, y) {
      let player = [state.begin, switchPlayer(state.begin)][
        state.moves.length % 2
      ];
      if (isMoveValid(player, x, y)) {
        if (player == CROSS) {
          drawCross(x, y);
        } else {
          drawCircle(x, y);
        }
        state.moves.push({ x, y });
        let status = isPlayerWinning(player, getBoard());
        if (status || state.moves.length == 9) {
          if (status) {
            drawWinnerLine(status);
            state.winners.push(player);
          }
          state.moves = [];
          setTimeout(drawBoard, 1000);
        }
      }
    }

    function isPlayerWinning(player, gameBoard) {
      for (let i = 0; i < 3; i++) {
        if (
          gameBoard[i][0] == player &&
          gameBoard[i][1] == player &&
          gameBoard[i][2] == player
        ) {
          return { type: "row", y: i };
        }
      }
      for (let i = 0; i < 3; i++) {
        if (
          gameBoard[0][i] == player &&
          gameBoard[1][i] == player &&
          gameBoard[2][i] == player
        ) {
          return { type: "col", x: i };
        }
      }
      if (
        gameBoard[0][0] == player &&
        gameBoard[1][1] == player &&
        gameBoard[2][2] == player
      ) {
        return { type: "diag", slope: -1 };
      }
      if (
        gameBoard[0][2] == player &&
        gameBoard[1][1] == player &&
        gameBoard[2][0] == player
      ) {
        return { type: "diag", slope: 1 };
      }
      return false;
    }

    function minimax(player, gameBoard) {
      console.log(gameBoard);
      empty = [];
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (!gameBoard[i][j]) {
            empty.push({ x: i, y: j, score: -Infinity });
          }
        }
      }
      if (empty.length == 1) {
        let newGameBoard = gameBoard.slice();
        newGameBoard[empty[0].x][empty[0].y] = player;
        if (isPlayerWinning(player, newGameBoard)) {
          return { score: Infinity };
        } else if (isPlayerWinning(switchPlayer(player), newGameBoard)) {
          return { score: -Infinity };
        } else {
          return { score: 0 };
        }
      }
      for (let cell in empty) {
        let newGameBoard = gameBoard.slice();
        newGameBoard[empty[cell].x][empty[cell].y] = player;
        empty[cell].score = minimax(switchPlayer(player), newGameBoard).score;
      }
      let MaxCell = empty[0];
      for (let cell in empty) {
        if (empty[cell].score > MaxCell.score) {
          MaxCell = empty[cell];
        }
      }
      return MaxCell;
    }

    function getBoard() {
      let gameBoard = [
        [null, null, null],
        [null, null, null],
        [null, null, null],
      ];
      let player = state.begin;
      for (let move of state.moves) {
        gameBoard[move.y][move.x] = player;
        player = switchPlayer(player);
      }
      return gameBoard;
    }

    function AI() {
      let player = [state.begin, switchPlayer(state.begin)][
        state.moves.length % 2
      ];
      gameBoard = getBoard();
      let bestMove = minimax(player, gameBoard);
      console.log(bestMove);
    }

    function handleClick(e) {
      const x = Math.floor((e.clientX - game.wBegin) / game.boxSide);
      const y = Math.floor((e.clientY - game.hBegin) / game.boxSide);
      if (x >= 0 && x <= 2 && y >= 0 && y <= 2) markCell(x, y);
    }

    function initGame() {
      state.begin = CIRCLE;
      state.moves = [];
      state.winners = [];
      drawBoard();
      board.addEventListener("click", handleClick);
      window.addEventListener("resize", () => {
        clearTimeout(throttle);
        throttle = setTimeout(() => {
          drawBoard();
        }, 100);
      });
    }

    window.onload = initGame;
  </script>
</html>
