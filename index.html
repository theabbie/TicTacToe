<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow-y: hidden;
      }
      * {
        box-sizing: border-box;
      }
      #board {
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
      }
      line,
      path,
      circle {
        stroke-linecap: round;
        stroke-dasharray: 850;
        stroke-dashoffset: 850;
        animation: draw 0.6s linear forwards;
      }
      line {
        animation-duration: 1s;
      }
      @keyframes draw {
        to {
          stroke-dashoffset: 0;
        }
      }
    </style>
    <title>Tic Tac Toe</title>
  </head>
  <body>
    <svg id="board"></svg>
  </body>
  <script>
    let game = {};
    let state = {};
    const board = document.querySelector("#board");
    const windowWidth = "100%";
    const windowHeight = "100vh";
    board.setAttribute("width", windowWidth);
    board.setAttribute("height", windowHeight);
    board.style.backgroundColor = "#121212";

    const CROSS = "X";
    const CIRCLE = "O";

    function drawLine(x1, y1, x2, y2, color) {
      const line = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "line"
      );
      line.setAttribute("x1", x1);
      line.setAttribute("y1", y1);
      line.setAttribute("x2", x2);
      line.setAttribute("y2", y2);
      line.setAttribute("stroke", color || "white");
      line.setAttribute("stroke-width", game.strokeWidth);
      board.appendChild(line);
    }

    function drawBoard() {
      let w = board.clientWidth;
      let h = board.clientHeight;
      game.side = Math.min(w, h) / 1.2;
      game.boxSide = game.side / 3;
      game.cellPadding = game.boxSide / 6;
      game.strokeWidth = game.boxSide / 19;
      if (w > h) {
        game.wBegin = (w - game.side) / 2;
        game.hBegin = (h - game.side) / 2;
        for (let i = 1; i <= 2; i++) {
          drawLine(
            game.wBegin + i * game.boxSide,
            game.hBegin,
            game.wBegin + i * game.boxSide,
            game.hBegin + game.side
          );
          drawLine(
            game.wBegin,
            game.hBegin + i * game.boxSide,
            game.wBegin + game.side,
            game.hBegin + i * game.boxSide
          );
        }
      } else {
        game.wBegin = (w - game.side) / 2;
        game.hBegin = (h - game.side) / 2;
        for (let i = 1; i <= 2; i++) {
          drawLine(
            game.wBegin,
            game.hBegin + i * game.boxSide,
            game.wBegin + game.side,
            game.hBegin + i * game.boxSide
          );
          drawLine(
            game.wBegin + i * game.boxSide,
            game.hBegin,
            game.wBegin + i * game.boxSide,
            game.hBegin + game.side
          );
        }
      }
    }

    function drawCross(x, y) {
      const cross = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      cross.setAttribute(
        "d",
        `M${game.wBegin + game.cellPadding + x * game.boxSide},${
          game.hBegin + game.cellPadding + y * game.boxSide
        } L${game.wBegin - game.cellPadding + (x + 1) * game.boxSide},${
          game.hBegin - game.cellPadding + (y + 1) * game.boxSide
        } M${game.wBegin + game.cellPadding + x * game.boxSide},${
          game.hBegin - game.cellPadding + (y + 1) * game.boxSide
        } L${game.wBegin - game.cellPadding + (x + 1) * game.boxSide},${
          game.hBegin + game.cellPadding + y * game.boxSide
        }`
      );
      cross.setAttribute("stroke", "white");
      cross.setAttribute("stroke-width", game.strokeWidth);
      board.appendChild(cross);
    }

    function drawCircle(x, y) {
      const circle = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      circle.setAttribute("cx", game.wBegin + (x + 0.5) * game.boxSide);
      circle.setAttribute("cy", game.hBegin + (y + 0.5) * game.boxSide);
      circle.setAttribute("r", game.boxSide / 2 - game.cellPadding);
      circle.setAttribute("stroke", "white");
      circle.setAttribute("stroke-width", game.strokeWidth);
      circle.setAttribute("fill", "none");
      board.appendChild(circle);
    }

    function switchPlayer(player) {
      if (player == CROSS) {
        return CIRCLE;
      } else {
        return CROSS;
      }
    }

    function isMoveValid(player, x, y) {
      for (let move of state.moves) {
        if (move.x == x && move.y == y) {
          return false;
        }
      }
      return true;
    }

    function drawWinnerLine(winner) {
      switch (winner.type) {
        case "row":
          drawLine(
            game.wBegin + game.boxSide / 2,
            game.hBegin + (winner.x + 0.5) * game.boxSide,
            game.wBegin + game.side - game.boxSide / 2,
            game.hBegin + (winner.x + 0.5) * game.boxSide,
            "red"
          );
          break;
        case "col":
          drawLine(
            game.wBegin + (winner.x + 0.5) * game.boxSide,
            game.hBegin + game.boxSide / 2,
            game.wBegin + (winner.x + 0.5) * game.boxSide,
            game.hBegin + game.side - game.boxSide / 2,
            "red"
          );
          break;
        case "diag":
          if (winner.x == 0) {
            drawLine(
              game.wBegin + game.boxSide / 2,
              game.hBegin + game.boxSide / 2,
              game.wBegin + game.side - game.boxSide / 2,
              game.hBegin + game.side - game.boxSide / 2,
              "red"
            );
          }
          else {
            drawLine(
              game.wBegin + game.boxSide / 2,
              game.hBegin + game.side - game.boxSide / 2,
              game.wBegin + game.side - game.boxSide / 2,
              game.hBegin + game.boxSide / 2,
              "red"
            );
          }
          break;
      }
    }

    function markCell(x, y) {
      let player = [state.begin, switchPlayer(state.begin)][
        state.moves.length % 2
      ];
      if (isMoveValid(player, x, y)) {
        if (player == CROSS) {
          drawCross(x, y);
        } else {
          drawCircle(x, y);
        }
        state.moves.push({ x, y });
        drawWinnerLine(isPlayerWinning(player, getBoard()));
      }
    }

    function isPlayerWinning(player, gameBoard) {
      for (let i = 0; i < 3; i++) {
        if (
          gameBoard[i][0] == player &&
          gameBoard[i][1] == player &&
          gameBoard[i][2] == player
        ) {
          return { type: "row", x: i };
        }
      }
      for (let i = 0; i < 3; i++) {
        if (
          gameBoard[0][i] == player &&
          gameBoard[1][i] == player &&
          gameBoard[2][i] == player
        ) {
          return { type: "col", x: i };
        }
      }
      if (
        gameBoard[0][0] == player &&
        gameBoard[1][1] == player &&
        gameBoard[2][2] == player
      ) {
        return { type: "diag", x: 0 };
      }
      if (
        gameBoard[0][2] == player &&
        gameBoard[1][1] == player &&
        gameBoard[2][0] == player
      ) {
        return { type: "diag", x: 1 };
      }
      return false;
    }

    function minimax(player, gameBoard) {
      console.log(gameBoard);
      empty = [];
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (!gameBoard[i][j]) {
            empty.push({ x: i, y: j, score: -Infinity });
          }
        }
      }
      if (empty.length == 1) {
        let newGameBoard = gameBoard.slice();
        newGameBoard[empty[0].x][empty[0].y] = player;
        if (isPlayerWinning(player, newGameBoard)) {
          return { score: Infinity };
        } else if (isPlayerWinning(switchPlayer(player), newGameBoard)) {
          return { score: -Infinity };
        } else {
          return { score: 0 };
        }
      }
      for (let cell in empty) {
        let newGameBoard = gameBoard.slice();
        newGameBoard[empty[cell].x][empty[cell].y] = player;
        empty[cell].score = minimax(switchPlayer(player), newGameBoard).score;
      }
      let MaxCell = empty[0];
      for (let cell in empty) {
        if (empty[cell].score > MaxCell.score) {
          MaxCell = empty[cell];
        }
      }
      return MaxCell;
    }

    function getBoard() {
      let gameBoard = [
        [null, null, null],
        [null, null, null],
        [null, null, null],
      ];
      let player = state.begin;
      for (let move of state.moves) {
        gameBoard[move.y][move.x] = player;
        player = switchPlayer(player);
      }
      return gameBoard;
    }

    function AI() {
      let player = [state.begin, switchPlayer(state.begin)][
        state.moves.length % 2
      ];
      gameBoard = getBoard();
      let bestMove = minimax(player, gameBoard);
      console.log(bestMove);
    }

    function handleClick(e) {
      const x = Math.floor((e.clientX - game.wBegin) / game.boxSide);
      const y = Math.floor((e.clientY - game.hBegin) / game.boxSide);
      if (x >= 0 && x <= 2 && y >= 0 && y <= 2) markCell(x, y);
    }

    function initGame() {
      drawBoard();
      board.addEventListener("click", handleClick);
      state.begin = CIRCLE;
      state.moves = [];
    }

    window.onload = initGame;
  </script>
</html>
